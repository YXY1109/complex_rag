# 技术决策文档

## 架构决策记录

### 1. 技术栈选择

#### 决策：使用 uv 作为包管理器
**理由**：
- 现代化的Python包管理器，性能优于pip
- 更好的依赖解析和锁定机制
- 支持Python版本管理和虚拟环境

**替代方案**：pip、poetry（已放弃）

#### 决策：FastAPI + Sanic 双框架架构
**理由**：
- FastAPI适合API层，提供丰富的生态和文档
- Sanic适合AI服务，单进程模式性能最佳
- 两个框架异步性能都很优秀，符合高并发需求

**替代方案**：Django（过重）、Flask（性能不足）

#### 决策：Trio 替代 Celery
**理由**：
- Trio提供更好的异步控制结构
- 更好的错误处理和资源管理
- 更轻量级，符合项目需求

**替代方案**：Celery（复杂度过高）、asyncio（控制结构较差）

### 2. AI服务接口设计

#### 决策：统一OpenAI API规范
**理由**：
- OpenAI API已成为事实上的行业标准
- 便于模型替换和生态兼容
- 前端可以无缝接入不同的AI服务

**技术细节**：
- `/v1/chat/completions` - LLM服务
- `/v1/embeddings` - 向量化服务
- `/v1/rerank` - 重排服务（自定义扩展）

#### 决策：Sanic单进程模式
**理由**：
- 根据RAGFlow的实践经验，单进程模式性能最佳
- 避免多进程的复杂性和资源竞争
- 简化部署和运维

### 3. 数据库设计

#### 决策：多租户架构设计
**理由**：
- 企业级应用的必备功能
- 支持多用户、多组织使用
- 提供良好的数据隔离和权限管理

**实现方案**：
```python
class TenantBaseModel(BaseModel):
    tenant_id = Column(String(32), nullable=False, index=True)
```

#### 决策：MySQL作为首选关系数据库
**理由**：
- 成熟的生态系统，稳定可靠
- 丰富的ORM支持
- RAGFlow使用MySQL，有现成的最佳实践

**扩展方案**：PostgreSQL（作为预留扩展）

#### 决策：UUID主键设计
**理由**：
- 避免自增ID泄露业务信息
- 支持分布式环境
- 更好的安全性

### 4. 文档解析架构

#### 决策：基于RAGFlow的文档处理架构
**理由**：
- RAGFlow在生产环境中经过验证
- DeepDoc提供高质量的视觉识别能力
- rag/app架构体现了业务导向的处理思路

**实现方案**：
- 直接复制RAGFlow的核心组件
- 适配到项目的异步架构
- 保持与RAGFlow的兼容性

#### 决策：文件来源分类处理
**理由**：
- 超越通用解析器，针对业务场景优化
- 不同来源的文档有不同的特征和处理需求
- 提供更高质量的解析结果

**分类方案**：
1. **web_documents** - 网页文档
2. **office_documents** - Office文档
3. **scanned_documents** - 扫描文档
4. **structured_data** - 结构化数据
5. **code_repositories** - 代码仓库

### 5. RAG核心功能

#### 决策：Mem0对话记忆管理
**理由**：
- 专业的对话记忆管理工具
- 支持长期记忆和短期记忆
- 提供上下文检索和问题重写

#### 决策：LangGraph召回组件架构
**理由**：
- 节点化的工作流设计，易于理解和调试
- 支持复杂的条件跳转和并行执行
- 便于实现多种召回策略的组合

#### 决策：集成RAGFlow GraphRAG
**理由**：
- RAGFlow的GraphRAG实现已经过生产验证
- 提供General和Light两种模式
- 包含实体抽取、关系解析、社区发现等完整功能

### 6. 开发工具和流程

#### 决策：分离式配置管理
**理由**：
- 不同服务有不同的配置需求
- 便于配置的管理和维护
- 支持环境特定的配置覆盖

**配置结构**：
```
config/
├── services/              # 服务配置
├── ragflow_configs/        # RAGFlow参考配置
└── secrets/                # 敏感配置
```

#### 决策：渐进式开发策略
**理由**：
- 降低复杂项目失败的风险
- 确保每个阶段都有可用的功能
- 便于根据实际情况调整计划

**实施阶段**：
1. 基础架构搭建
2. 核心功能实现
3. 高级功能扩展
4. 测试和优化

### 7. 代码质量

#### 决策：严格的代码质量要求
**理由**：
- 确保代码的可维护性和一致性
- 提高开发效率和团队协作
- 减少生产环境的bug

**工具链**：
- **Black** - 代码格式化
- **iSort** - 导入排序
- **MyPy** - 静态类型检查
- **Flake8** - 代码风格检查

#### 决策：单元测试优先
**理由**：
- 逐步实施，避免测试债务
- 确保代码质量的基础
- 为集成测试打下基础

## 被拒绝的替代方案

### 1. 微服务架构过于复杂
**拒绝原因**：初期项目复杂度不够，单体架构更适合

### 2. 用户认证系统
**拒绝原因**：前期不需要，简化API设计，专注核心功能

### 3. 复杂的测试体系
**拒绝原因**：前期只专注于单元测试，集成测试和E2E测试后期添加

### 4. 复杂的CI/CD流水线
**拒绝原因**：初期手动部署即可，CI/CD等系统稳定后再考虑

## 技术债务管理

### 当前已知的技术债务
1. **配置管理**：配置文件较多，需要更好的管理工具
2. **错误处理**：需要统一的异常处理机制
3. **日志规范**：需要更详细的日志规范和监控

### 债务技术债务
1. **性能优化**：当前架构可能存在性能瓶颈
2. **安全加固**：需要加强API安全和数据保护
3. **监控告警**：需要完善的生产监控体系

## 未来技术演进方向

### 短期（3-6个月）
1. **性能优化**：基于实际使用数据优化性能瓶颈
2. **安全加固**：添加API认证、权限管理、数据加密
3. **监控完善**：实现完整的监控和告警体系

### 中期（6-12个月）
1. **CI/CD流水线**：实现自动化部署和测试
2. **扩展功能**：根据实际需求添加新功能
3. **多语言支持**：支持更多语言的文档处理

### 长期（1-2年）
1. **微服务拆分**：如果系统规模扩大，考虑拆分为微服务
2. **AI能力扩展**：支持更多AI模型和功能
3. **企业级特性**：添加更多企业级功能特性

## 总结

这些技术决策基于项目的实际需求和RAGFlow的最佳实践。核心原则是：
- 简单而有效，避免过度设计
- 基于成熟的解决方案，降低风险
- 支持渐进式演进，保持灵活性
- 注重代码质量和可维护性

每个决策都有明确的理由和实现方案，为项目的成功实施奠定了坚实的技术基础。